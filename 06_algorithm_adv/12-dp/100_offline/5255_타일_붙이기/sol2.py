import sys
sys.stdin = open('input.txt')


# 본 코드는 SWEA에 제출 불가입니다.

import numpy as np


def mat_pow(mat, exp):
    # 결과 행렬을 단위 행렬로 초기화 (3x3 단위행렬)
        # 단위 행렬은 어떤 행렬과 곱해도 원래 행렬을 그대로 반환하므로...
    result = np.identity(3, dtype=int)
    base = mat  # 베이스를 변환행렬 M으로 설정하고,
    while exp:  # 지수 만큼
        # 만약 현재 지수가 홀수이면, result에 base 행렬을 일단 곱해
        # 지수를 짝수로 만든다. -> 연산의 편의성을 위해
        if exp % 2:
            result = np.matmul(result, base)
        # base 행렬을 제곱하여 업데이트
            # 왜 하는가?
            # base²ⁿ == (baseⁿ)² 이므로, 곱셈 연산 횟수를 줄이기 위해
        base = np.matmul(base, base)
        # 지수를 절반으로 줄임
        exp //= 2
    return result


def matrix(n):
    # basis
    if n == 1:
        return 1
    elif n == 2:
        return 3
    elif n == 3:
        return 6

    # 변환 행렬 M 정의
    '''
        점화식 F(n) = F(n-1) + 2*F(n-2) + F(n-3)를 행렬 곱셈으로 표현하기 위해
        상태 벡터를 [F(n), F(n-1), F(n-2)]ᵀ로 정의 한다면, 아래 형태가 될 수 있어야 함.
            [F(n), F(n-1), F(n-2)]ᵀ = M * [F(n-1), F(n-2), F(n-3)]ᵀ
        위 식이 성립 하기 위해서
        M의 각 행은
        - 첫 번째 행 [1, 2, 1]: 
            - F(n)과 이전 상태벡터 [F(n-1), F(n-2), F(n-3)]ᵀ 에 대한 내적을 위해 각각의 계수 작성.
            - 점화식을 그대로 표현한 것과 같음.
        - 두 번째 행 [1, 0, 0]
            - 1*F(n-1) + `0*F(n-2) + 0*F(n-3)` = F(n-1)
            - 상태 벡터의 첫 번째 원소인 F(n-1)를 그대로 다음 상태의 두 번째 위치로 전달 
        - 세 번째 행 [0, 1, 0]
            - F(n-2) 역시 F(n-1)과 동일.
    '''
    M = np.array([[1, 2, 1],
                  [1, 0, 0],
                  [0, 1, 0]])

    # 행렬 거듭 제곱으로 F(n)을 정의하기 위해 필요한 초기 상태
    # 초기 상태 벡터 정의
    # (n = 3, 2, 1에 해당하는 값들)
    vector = np.array([[6], [3], [1]])
    '''
                                      F(3)   6  
        M * vector 즉,       vector = F(2) = 3  
                                      F(1)   1
                                      
        M의 각 행의 역할을 생각했을 때,
            F(3)   F(4)     : 이전 상태 벡터에 대해 F(n)을 내접한 결과와 동일
        M * F(2) = F(3)     : 상태 벡터의 첫 행의 값을 그대로 이전하여 사용
            F(1)   F(2)     : 상태 벡터의 두번째 행의 값을 그대로 이전하요 사용
        
        한 번 더 곱하게 된 경우,
        
             F(3)   F(5)     : 이전 상태 벡터에 대해 F(n)을 내접한 결과와 동일
        M² * F(2) = F(4)     : 상태 벡터의 첫 행의 값을 그대로 이전하여 사용
             F(1)   F(3)     : 상태 벡터의 두번째 행의 값을 그대로 이전하요 사용
              
        따라서, F(n), F(n-1), F(n-2)를 구하고자 한다면
        M ** (n-3) 을 진행하면 얻을 수 있다.
               F(3)   F(n)    
        Mⁿ-³ * F(2) = F(n-1)  
               F(1)   F(n-2)        
    '''
    # M을 (n-3)제곱하여 점화식을 확장
    Mn = mat_pow(M, n-3)

    # Mn과 초기 상태 벡터를 곱해서 n번째 항 계산
    res = np.matmul(Mn, vector)
    # 결과 벡터의 첫 번째 원소가 n번째 항
    return res[0][0]

T = int(input())

for tc in range(1, T+1):
    N = int(input())
    '''
        2*1, 2*2, 2*3 상자로 만들 수 있는 2*n 의 경우
        - 2는 고정, n의 크기에 따라 설정할 수 있는 경우가 달라짐. 
        
        1. 2*1을 하나 세로로 사용하는 경우,
            - n만큼의 너비중, 1만큼의 경우 삭제
                - 즉, n-1 번째 경우의 수와 같은 수의 가짓수로 해결 가능     
        2. 2*2를 채우는 방법 2가지
            - (2*1 을 세로로 놓는 방법은 1번에서 사용하고 있으므로 제외)
            - 2*1 을 가로로 2개 놓는 방법
            - 2*2 를 사용하는 방법
                - 결론은 n 만큼의 너비 중, 2만큼의 너비에 대해 생각 할 필요 없어짐.
                - 단 방법이 2가지 이므로 2를 곱함.
                - 즉, 2(n-2)
        3. 2*3으로 채우는 방법
            - 1번과 동일
                즉, n-3 번째 경우의 수와 같은 수의 가짓수로 해결 
            
        점화식 ->F(n) =  F(n-1) + 2F(n-2) + F(n-3)
    '''
    print(f"#{tc} {matrix(N)}")
