import sys
sys.stdin = open('input.txt')


#     상  하 좌 우
dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]
'''
    알고리즘 문제를 풀기 위한 함수를 정의할 때,
    보통 tc, 테스트케이스 반복문 바깥쪽에 정의를 하는 이유는,
    모든 테스트 케이스마다 동일한 함수를 사용할 것이기 때문에,
    매번 테스트케이스가 실행 될 때마다 (range(1, T+1) => 1 ~ T)
    함수가 정의 되도록 할 필요는 없기 때문이다. (함수의 정의도 코드의 연산과정이 필요하다.)
    리스트의 상하좌우 좌표로 사용하기 위한 dx, dy 리스트도 마찬가지이다.
'''
def search(x, y):
    count = data[x][y]   # 누적할 값의 초기값을 (x, y) 번째 값으로 초기화 해 둔다.
    for k in range(4):  # 4방향을 탐색할 예정.
        nx = x + dx[k]
        ny = y + dy[k]
        '''
            dx와 dy의 k번째는 아래와 같다.
                  0   1  2  3
            dx = [-1, 1, 0, 0]
                  0  1   2  3
            dy = [0, 0, -1, 1]
            
            순서대로 상, 하, 좌, 우의 위치의 좌표를 나타낼 수 있게 작성하였다.
            순서는 본인이 필요한 상황에 따라 다르게 나타낼 수도 있다.
            좌우하상이 될 수도 있고, 우와 상만 조회해야 하는 경우도 있을 수 있다.
            중요한 것은 왜 `x + dx[k]` 가 x 위치에서 상 하 좌 우가 될 수 있느냐 이다.
            
                           0    1    2  Y
                       0 ['A', 'B', 'C']
                       1 ['D', 'E', 'F']
                       2 ['G', 'H', 'I']
                       X
            1. data[x][y] -> x = 1, y = 1 일때 리스트의 [1][1] 위치를 의미한다.
            2. 위 리스트 기준으로 data[1][1] == 'E' 이다.
            3. 이때, k가 0 이라면, x + dx[0], y + dy[0] 을 대입하면
                -> dx[0] == -1, dy[0] = 0
                -> x + (-1), y + 0
                -> 1 + (-1), 1 + 0
                -> (0, 1)
            4. 위 식의 실행 결과 nx, ny는 각각 0, 1이 된다.
            5. 이 때 data[nx][ny] => data[0][1] => 'B' 가 된다.
                - 즉, 'E'의 바로 윗칸에 해당하는 좌료를 탐색 할 수 있게 된다.
                - 나머지 방향에 대해서도 동일한 식이 실행되므로 손으로 그려보자.            
        '''
        if 0 <= nx < N and 0 <= ny < M:
            '''
                x, y 위치를 기준으로 찾아낸 4 방향에 대해서
                nx, ny의 값이 0보다는 크거나 같고 각각 N, M보다는 작아야한다.
                nx, ny 둘 중 하나라도 -1 이상이 되면, 파이썬의 리스트는
                마지막 위치를 조회하게 된다.
                따라서, data[-1][y] or data[x][-1] 과 같은 전혀 엉뚱한 위치를 조회한다.
                위 리스트를 기준으로 'A'에서 조사할 시, 탐색해야 하는 범위는
                    'A', 'B', 'D' 이지만, -1도 조회하면 'C', 'G'도 포함된다.
                    data[-1][0] => 'G', data[0][-1] => 'C'
                nx, ny가 각각 N, M과 같은 값이 되면
                    data[3][0] or data[0][3] 과 같이 리스트의 범위를 벗어나\
                    index error가 발생하게 된다.
            '''
            # 조건을 통과하였다면, 해당 위치에 있는 값을 count에 더해준다.
            count += data[nx][ny]
    # 조사 시작위치 x, y를 기준으로 4방향 탐색이 모두 끝났다면,
    # == for k in range(4)를 모두 실행하였다면,
    # 그때까지 누적된 count를 반환한다.
    return count

T = int(input())

for tc in range(1, T+1):
    # N = 세로, M = 가로
    N, M = map(int, input().split())
    # N번에 걸쳐 데이터 입력
    data = [list(map(int, input().split())) for _ in range(N)]
    # # 입력 데이터 출력 확인
    # # 데이터 출력 후, 출력 결과의 sol(1) 이라고 적힌 부분에
    # # 우클릭하여, pin tab을 눌러주면,
    # # 이후에는 아래 코드를 주석 처리하고 코드를 다시 실행 시켜도
    # # 그 결과는 고정되어 있어 재 확인 할 수 있다.
    # for i in range(N):
    #     print(data[i])
    # print()

    result = 0  # 최종 결과가 될 대상, 최댓값이 맞는지 비교할 대상
    '''
          0  1  2  3  4  M
       0 [2, 1, 1, 2, 2]
       1 [3, 1, 5, 1, 2]
       2 [3, 4, 1, 1, 2]
       N
        위 풍선 데이터에서 data[1][2] 좌표의 값은 5이다.
        데이터를 눈으로 보았을 때, 제일 큰 값인 5를 기준으로
        상하좌우의 값을 더하면 가장 큰 값이 될 것 처럼 보이지만
        가장 큰 값이 되는 경우는 data[2][0] 의 3에서 상하좌우 중,
        더할 수 있는 값들 3 + 3 + 4가 10으로 가장 크다.
        즉, 단순히 값 하나가 가장 큰 수를 찾는 경우가 아니라면
        조건에 맞췄을 때, 어느 값이 가장 클 지 알 수 없으므로
        - 반드시 모든 상황에 대해 조사를 진행해야 한다.
        따라서, N*M 크기에 대해 전수 조사를 진행한다.
    '''
    for x in range(N):      # 세로 크기 N
        for y in range(M):  # 가로 크기 M
            # print(data[x][y], x, y)    순회 순서 확인
            '''
                2중 for문의 작동 순서는
                104번째 줄의 코드가 실행되면서 x에 우선 0이 삽입된다.    
                    range(N) => 0 ~ N-1
                이후, 105번째 줄의 코드가 실행되면서 y에 0이 삽입된다.
                    range(M) => 0 ~ M-1
                이때, data[x][y] 를 print하게 되면,
                data[0][0] 좌표의 값 2가 출력된다.
                
                다음에 실행될 코드가 남아 있다면, 해당 코드를 실행하고
                없다면 다시 105번째 줄로 돌아가서 y에 1이 삽입된다. (M이 2 이상이라면)
                    x는 증가하지 않는 이유는,
                    아직 105번째줄의 for문의 코드가 끝나지 않았기 때문이며,
                    y가 M-1이 될 때 까지 반복해서 코드가 실행 된 후에야 
                    x가 1 증가하게 된다.
                
                따라서, 코드의 실행 순서는 아래와 같다.
                    x = 0, y = 0
                    x = 0, y = 1
                    x = 0, y = 2
                        ...
                    x = 0, y = M-1  105번째 줄 for문 종료,
                    
                    104번째 줄 for문의 다음 값이 x에 삽입
                    x = 1, y = 0
                    x = 1, y = 1
                    x = 1, y = 2
                        ...
                        
                    x = N-1, y = 0
                    x = N-1, y = 1
                    x = N-1, y = 2
                        ...
                    x = N-1, y = M-1
                    모두 순회 완료
                    
                    이렇게 (0, 0) 부터 (N-1, M-1) 까지 모든 상황에 대해
                    본인을 포함한 상하좌우의 값을 모두 더했을 때,
                    가장 큰 값을 찾아야 하므로,
                    모든 x와 y에 대해서 아래의 함수를 실행한다.
            '''
            count = search(x, y)    # 현재 위치로부터 4방향 탐색
            # search 함수의 반환값은 x, y를 기준으로 4방향을 모두 탐색한 뒤
            # 얻은 누적 값들의 합이다.
            # 최종 출력 예정값은 이 count들 중, 가장 큰 값이므로
            if result < count:  # 이번 순회를 통해 얻은 count가 result 보다 크다면
                result = count  # result의 값을 count로 바꿔준다.

    # 모든 x, y에 대해 조사를 마쳤다면, 결과 출력
    print(f'#{tc} {result}')



