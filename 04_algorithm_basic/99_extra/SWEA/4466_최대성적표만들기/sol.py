import sys
sys.stdin = open('input.txt')


def enQueue(last, score):
    heap[last] = score  # 값 삽입
    child = last  # 내 현재 위치 표기
    parent = child // 2
    while parent != 0:  # 부모 노드가 0이 되기 전까지
        if heap[child] < heap[parent]:  # 부모 노드의 값이 자식 노드 값보다 크다면,
            # 현재 자식 노드의 값이 루트 노드로 옮겨가야 하므로 두 값을 swap
            heap[child], heap[parent] = heap[parent], heap[child]
        # 내 현재 위치가 원래 부모의 위치로 바뀌었으므로 내 위치 재 정의
        child = parent
        # 내 위치가 바뀌었으므로 내 부모를 다시 정의
        parent = child // 2


# 삭제 연산시에는 루트 노드와 단말노드의 인덱스만 알면되므로 별도 인자 불필요
def deQueue():
    '''
        필요하다면, K번 최단말 노드의 값을 None으로 변경하거나 충분히 큰값
        현재 문제에서는 101 등으로 변경할 수 있으나, 불필요한 작업.
        -> score가 1번보다 커서 새로 삽입하기 위해 빈자리를 만들고 있으므로
        deQueue 작업이 마무리 되면 바로 enQueue(K, score) 작업을 진행 할 것이다.
    '''
    heap[1] = heap[K]   # K번째 노드의 값을 루트 노드에 할당한다.

    # 다시 최소 힙 구성
    node = 1    # 현재 위치 루트 노드

    while node * 2 + 1 <= K:    # 노드 번호가 K와 같아지기 전까지
        left_child_index = node * 2         # 왼쪽 자식
        right_child_index = node * 2 + 1    # 오른쪽 자식
        min_index = left_child_index        # 최소 값의 위치를 왼쪽 자식이라고 가정

        # 오른쪽 자식 번호가 최종 노드번호보다 작고,
        # 오른쪽 자식이 왼쪽 자식보다 작다면
        if right_child_index <= K and heap[right_child_index] < heap[left_child_index]:
            # 최소 값의 위치를 오른쪽 자식으로 확정
            min_index = right_child_index

        # 왼쪽과 오른쪽 자식중, 더 작은 자식과 내 현재 위치를 비교
        # 내 자식중 나보다 큰 값이 있다면
        if heap[node] > heap[min_index]:
            # 두 값을 변경하고
            heap[node], heap[min_index] = heap[min_index], heap[node]
            node = min_index    # 내 위치 초기화
        else:
            # 그 외의 경우 : 내가 자식들보다 더 작다면
            return  # 조사 종료

T = int(input())
for tc in range(1, T+1):
    # N = 전체 정수의 개수, K = 출력할 값의 수
    N, K = map(int, input().split())
    # 전체 데이터
    data = list(map(int, input().split()))
    # print(data)
    '''
        1. 파이썬에서의 풀이
        - sorted(iterable, reverse=True)
            순회 가능 요소를 내림차순으로 정렬하여
            sorted 객체를 반환 (list와 비슷하지만 다르다.)
            reverse=True를 작성하지 않으면 오름차순으로 정렬
            요소가 문자열인 경우에도 사전순으로 정렬한다.
            
        - sorted(...)[:K]
            정렬된 요소 sorted 객체도 list와 같이 슬라이싱이 가능
            K번째 까지의 요소만 사용한다.
            주의) K == 2 일때 K-1 까지만 사용한다.
                     0   1    2
            data = [100, 90, 80]
            data[:K] -> data[:2] -> [100, 90]
            
        - sum(iterable)
            순회 가능 객체가 가진 모든 요소를 더한다.
            단, 0에 더해나가므로 정수 0과 덧셈 계산이 가능하여야 한다.
    '''
    print(f'#{tc} {sum(sorted(data, reverse=True)[:K])}')

    '''
        2. 자료구조를 활용한 풀이
            - 다양한 방법이 있지만 이번 풀이에서는 완전 이진트리를 활용한다.
        
        1. 최대 사용 가능 노드 개수만큼 heap을 구성한다.
            1-1. 사용할 노드의 수는 K개이다.
            1-2. 삽입 가능한 위치를 파악하기 위한 index 를 초기화한다.
   '''
    heap = [0] * (K+1)  # 0번 노드는 사용하지 않는다.
    last = 1            # 1번 index 부터 삽입가능. 0번 노드는 없다.
    '''
        2. 사용가능한 모든 데이터에 대해서 조사진행.
            2-1. K개를 사용할 예정이므로 
                 우선은 사용할 데이터가 K가 될 때까지 삽입한다.
    '''
    for score in data:
        if last != K+1:
            '''
                2-2. 단, 삽입 과정에서, 값들의 우선순위를 정리한다.
                     여기서는 사용할 데이터중, 가장 작은 값을 루트 노드에 둔다.
                     예시) K = 7 일 때,  [100, 30, 90, 90, 10, 40, 70] 의 데이터가 삽입된다면,
                           완성시킬 목표 트리의 구성은 다음과 같다.
                                    1| 10
                            2| 30           3| 40
                        4| 100   5| 90   6| 90  7| 70
                    완성되어가는 과정은 다음과 같다.
                    
                    1. 100이 삽입된다. 이때, last = 1
                                    1| 100
                            2| None           3| None
                        4| None   5| None   6| None  7| None
                        
                        1-1. 100이 삽입된 1번 노드는 루트 노드이므로 추가 조사는 진행하지 않는다.
                        
                    2. last가 1 증가하고, 30이 삽입된다. 이때 last는 2
                                    1| 100
                            2| 30           3| None
                        4| None   5| None   6| None  7| None
                        
                        2-1. 30이 삽입된 다음, 루트노드가 아니므로 부모노드와 본인을 비교한다.
                        2-2. 루트노드에 가장 작은 값을 두는 것이 목표이므로... 두 값을 스왑한다.
                                    1| 30
                            2| 100           3| None
                        4| None   5| None   6| None  7| None
                    
                    3. last가 1증가하고, 90이 삽입된다. 이때 last는 3
                                    1| 30
                            2| 100           3| 90
                        4| None   5| None   6| None  7| None
                        
                        3-1. 90이 삽입된 다음, 루트 노드가 아니므로 부모와 비교하지만,
                             90의 값이 더 크므로 변화없음.
                             
                    4. last가 1증가하고, 다시, 90이 삽입된다. 이때 last는 4
                                    1| 30
                            2| 100           3| 90
                        4| 90   5| None   6| None  7| None
                        
                        4-1. 루트노드가 아니므로 부모와 비교한다. 
                        4-2. 4번 노드의 값 (90) < 2번 노드의 값 (100) : 두 값 스왑
                                    1| 30
                            2| 90           3| 90
                        4| 100   5| None   6| None  7| None
                        
                        4-3. 여전히 루트 노드가 아니므로 부모와 비교하지만,
                             90이 값이 더 크므로 변화없음.
                        
                    5. 위 과정을 끝까지 반복
                3. 위 과정을 위해선 값을 삽입한 last를 기준으로, 부모노드의 index가 필요,
                    - 내 현재 위치가 루트 노드가 되기 전까지 과정을 반복
                    - 이는 부모 노드의 index가 0인지 판별하면 된다.
                    - 현재 위치가 루트노드라면
                    - child == 1 -> parent == 1 // 2 -> parent == 0 
            '''
            # 데이터 삽입
            # 데이터 삽입만이 목적인 함수이므로 별도의 return 값은 없다.
            enQueue(last, score)

            # 모든 과정이 다 마무리 된 뒤에, last가 1 증가한다.
            last += 1
        else:   # last가 K가 되었다 -> heap의 마지막 노드까지 값이 모두 삽입 되었다.
            '''
                아래와 같이 heap에 K개 만큼의 값이 모두 차있다면,
                이때, 값이 모두 찼음을 확인 할 수 있는 방법은 last의 위치
                        0    1      2      3    last == K+1 (K개를 쓸 것이므로 last가 K+1일때가 포화)
                heap = [0, Value, Value, Value]   ↓
                
                heap이 가득 찬 경우에 마주한 score가 heap에 삽입 될 수 있는 경우는
                heap의 루트 노드 값보다 score가 큰 경우이다.
                heap에는 K를 사용했을 때 만들 수 있는 제일 큰 수를 만들고자 하므로
                루트 노드 (가장 작은 수 -> 최소 힙을 구성하고 있으므로) 와 score를 비교
            '''
            if heap[1] < score:     # 루트 노드의 노드번호 1
                '''
                    1. 최소 힙에서 값 삭제는 루트 노드의 값을 제거하는 것
                                    1| None     
                            2| 30           3| 40
                        4| 100   5| 90   6| 90  7| 70
                        
                        - 위와 같이 만들어야 한다.
                        1-1. 단, 우리는 최소 힙의 루트 노드의 값은 필요 없고,
                        1-2. score를 삽입하는 행위는 enQueue를 활용할 것이므로
                        1-3. 최 단말노드 (여기서는 K가 7이므로 7번노드)를 루트노드에 옮긴다음,
                        1-4. 최소힙이 되도록 다시 계산한다.
                        
                    2. 최소 힙에서 값 삭제후, 재 구성 방법
                                    1| 10   <- 해당 위치에 최단말노드의 값을 할당     
                            2| 30           3| 40
                        4| 100   5| 90   6| 90  7| None     <- 원 값 70을 None으로 바꾸지 않아도 무방
                        
                        결과. 여전히 마지막 노드 번호는 7로 고정 (이제부터 last는 변하지 않을 예정)
                                    1| 70        
                            2| 30           3| 40
                        4| 100   5| 90   6| 90  7| 70
                        
                        2-1. last가 변하지 않는 이유?
                            - 이번 풀이에서 최소 힙에서 값을 삭제하는 이유는
                              현재 heap 구성요소의 가장 작은 값보다 더 큰 값이 등장하여
                              가장 작은 값을 제거 한 후, 새로운 값을 삽입하기 위함이다.
                            - 따라서 이번 풀이에서의 heap은 모든 조사를 마칠때까지
                              항상 포화상태를 유지한다.
                              따라서, 포화상태가 된 이후 모든 삽입 행위는 항상 K번째에 값을 삽입한다.
                                주의) last는 한번 K+1이 되었으므로, 앞으로도 K+1 이다.
                                      값 삽입시에는 계산하기 편하게 하기 위해 heap[K] 번째에 삽입한다.
                        
                        2-2. 단말 노드를 루트로 끌어 올린 다음, 다시 최소힙이 구성될 수 있도록 조사
                                        1| 70        
                                2| 30           3| 40
                            4| 100   5| 90   6| 90  7| 70
                            
                            - 2번 노드의 값보다 1번 노드의 값이 더 크므로 swap
                            
                                        1| 30        
                                2| 70           3| 40
                            4| 100   5| 90   6| 90  7| 70    
                            
                            - 4번, 5번 노드보다 내가 더 작으므로 현상태 유지
                        
                        2-3. 최소힙 재구성을 위한 조사는 언제까지 진행해야 할까?
                            - 아래와 같은 데이터가 있다고 가정하자.
                            - 바뀐 점은 7번 노드의 값이 70에서 95로 변경된 것이다.
                            
                                        1| 10        
                                2| 30           3| 40
                            4| 100   5| 90   6| 90  7| 95    
                            
                            - 이전과 같이 최단말노드를 루트노드로 이동시킨다.
                            
                                        1| 95        
                                2| 30           3| 40
                            4| 100   5| 90   6| 90  7| 95
                            
                            - 이후 자식들과 값을 비교한다. -> 2번 노드와 swap
                                        1| 30        
                                2| 95           3| 40
                            4| 100   5| 90   6| 90  7| 95
                            
                            - 이후, 2번 노드 기준 4번 5번 노드와 비교, 5번 노드 90과 swap
                                        1| 30        
                                2| 90           3| 40
                            4| 100   5| 95   6| 90  7| 95
                            
                            - 이후, 5번 노드의 자식 (10과 11)번 노드는 K (heap의 최대크기)를 초과하므로
                            - 조사 종료.         
                '''
                # 새로 삽입될 값이 heap의 루트 노드 값보다 크므로 삭제 연산을 우선 진행
                deQueue()
                # 루트 노드의 값을 제거하고 최소힙을 제 구성 한 다음,
                # 이번 score를 K번째 위치에 삽입
                enQueue(K, score)

    # 모든 조사가 완료되었다면, heap에 들어있는 모든 값을 합한다.
    # 사용하지 않을 0 번 노드의 값을 0으로 초기화 해 두었으므로
    # 모두 더해도 값에 변동은 없다.
    result = 0
    for score in heap:
        result += score
    print(f'#{tc} {result}')

    '''
        이렇게 해도 sorted, sum, slicing을 쓴것보다 느린데요?
        -> 파이썬의 sorted는 최신 알고리즘이 적용되었다.
    '''
