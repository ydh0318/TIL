import sys
sys.stdin = open('input.txt')


T = int(input())

for tc in range(1, T+1):
    N = int(input())
    C = list(map(int, input().split()))

    # 모든 당근에 대해서 조사를 한다.
    '''
        당근의 크기가 다음과 같이 주어질 때,
         0  1  2  3  4  N
        [4, 5, 1, 2, 3]
        연속으로 증가한다는 의미는, 
        한 번이라도 내 다음번이 나보다 작다면,
        그 연결 과정은 시작지점이 어디서부터 였든 더 커질수 없다는 의미이다.
        예를들어,
        0번 부터 점차 커지는지를 확인하면
        4 -> 5 -> 1 순으로 탐색하여 총 길이 2가 된다.
        
        5 -> 1로 넘어가는 과정에서 연속성이 파괴되었으므로
        1번인 5번부터 재조사할 이유는 없다.
        
        그렇다면 다음 조사 위치는 1번부터 다시 조사를 시작하도록한다.
        1 -> 2 -> 3 순으로 점차 커지고 조사가 마무리 되어
        총 연속된 증가 값 길이는 3이된다.
        
        즉, 조사 범위는 0부터 N-1까지 순차적으로 진행한다.
    '''
    # 첫 조사 대상의 이전번 조사 대상
    prev_carrot = 0 # 가장 작은 값으로 초기화
    count = 0       # 연속으로 커진 당근의 수
    result = 0      # 최종적으로 출력할 값
    for carrot in C:
        '''
            이때, 비교해야 하는 값은,
            이번 조사 대상과 이전 조사 대상이 된다.
            혹은, 이번 조사 대상과 다음 조사 대상이 된다.
            둘 중, 이번 풀이에서는 이전번 조사 대상과 나를 비교하고자한다.
            그렇다면, 이전 조사 대상의 값을 어딘가에 기록한다.
        '''
        if carrot > prev_carrot:    # 이번 조사 당근이 이전보다 크다면,
            count += 1              # 길어진 횟수 1 증가
        else:
            '''
                아닌경우, 즉 이번 당근이 이전번보다 작거나 같다면,
                연속으로 증가하는 규칙이 깨졌으므로 count를 1로 초기화하고
                다시 처음부터 조사하도록 한다.
                count가 1로 초기화 되는 이유는,
                더 작아진 이번 위치 부터 조사를 진행해야 하므로, 이번 당근의 개수 1이 된다.
            '''
            '''
                단, 지금까지 조사한 값이 모든 경우에서 가장 클 수 있으므로
                최종적으로 출력하고자 하는 result와 비교해서
                이번 연속성 조사가 result보다 크다면 result에 count를 할당
            '''
            if result < count:
                result = count
            count = 1
        prev_carrot = carrot        # 다음 조사를 넘어가기전, 이번 조사 크기를 기록
    '''
        이대로 종료하게 되면 발생하는 문제는...
        만약, 한 번도 도중에 연속성이 끊기지 않고 끝까지 조사를 마친경우
        count의 값을 result에 할당해줄 기회가 없다.
        (count와 result를 비교하는 로직은 연속으로 증가하는 규칙이 깨졌을 때만 작성했으므로)        
    '''
    # 마지막으로 조사
    if result < count:
        result = count
    print(f'#{tc} {result}')
